# Задача Дирихле для уравнения Пуассона

## Условие задачи

1. Разобраться в последовательном (1.11) и параллельном алгоритме (1.16) решения задачи Дирихле для уравнения Пуассона из книги В. П. Гергеля
   [“Высокопроизводительные вычисления для
   многоядерных многопроцессорных систем” (2010)](https://github.com/artjomjuferov/university/blob/master/Beljakova/Гергель%20В.П.%20Высокопроизводительные%20вычисления%20для%20многоядерных%20многопроцессорных%20систем%20(2010).pdf)
2. Реализовать последовательный и параллельный алгоритмы.
3. Провести эксперимент, исследующий эффективность (или неэффективность) параллельного алгоритма.

## Условия проведения эксперимента
### Аппаратное обеспечение
- Процессор — **Apple M1 Pro (8 ядер)**
- Оперативная память — **16 GB**
- Операционная система — **macOS Sonoma 14.0**
- L1-кэш — **256 KB**
### Программное обеспечение
- Версия GCC - **13.2.0**
- Версия OpenMP - **4.5**
### Функции, для которых искалась аппроксимация:
- $`g(x, y) = 10x^{10} + 10y^{10}`$
- $`g(x, y) = 100*(1 - 2 * y)*(1 - 2 * x)`$
- $`g(x, y) = `$
- $`g(x, y) = `$
- $`g(x, y) = `$
### Количество повторений
ААА

## Обозначения
- $`D`$ - область, на которой задается функция. Для простоты берется единичный квадрат, на котором строится сетка.
- $`N`$ - размер сетки по любой из координат без включения границы.
- $`B`$ - размер стороны блока.
- $`g(x, y)`$ - функция, к которой приближаем.
- $`f(x, y)`$ - сумма частных производных второго порядка функции $`g(x,y)`$.
- $`EPS`$ - требуемая точность, то есть максимально допустимая разница между результатом приближения и истинным значением функции.
- $`t_b(a)`$ - время выполнения операции $`a`$ на $`b`$ потоках.

## Анализ эффективности работы параллельного алгоритма на нескольких потоках в сравнии с последовательным алгоритмом

### Ожидаемое показатели
Рассчитаем ожидаемое ускорение при распараллеливании.

#### Последовательный алгоритм
Для обработки сетки размером $`NxN`$ нам надо сделать $`N^2`$ действий на одну итерацию внешнего цикла. Таких итераций может быть много, их число определяется числом $`EPS`$ и начальными значениями функции, которую приблежаем.
Помимо этого, требуется время на все прочие операции (само приближение и т.д.) - обозначим все такие операции $`C`&. 
Тогда понятно, что для выполнения последовательного алгоритма понадобится время $`t_*(consistent) \approx i * (N^2 * C), \ C \in R`$.
Звездочка у $`t`$ - потомучто это будет верно на любом количестве потоков.

#### Параллельный алгоритм
Для обработки одного блока размером B, по аналогии со временем для выполнения последовательного алгоритма(внутри блока последовательное вычисление):
$`t(approximate_block_) \approx B^2 * C, \ C \in R`$
При обработки всей сетки у нас уйдет время, на нарастание волны, затухание волны и обработку прочих операций внутри блоков.
Понятно, что на последнее нам понадобится $`С * BN, \ C \in R`$ действий.
Для обработки нарастания волны нам понадобится $`\displaystyle\sum_{i=1}^{BN}
t_*(approximate_block)*ceil(i/a)`$ действий. Действительно, мы идем по блокам вдоль сетки, и на каждом шаге пытаемся распределить вычисление $`i`$-го количества блоков на $`a`$ потоков.
Аналогично, для обработки затухания волны: $`\displaystyle\sum_{i=1}^{BN-1}
t_*(approximate_block)*ceil(i/a)`$
Таким образом, на работу алгоритма уйдет время: $`t_a(approximate) \approx iter * (\displaystyle\sum_{i=1}^{BN} t_*(approximate_block) * ceil(i/a) + \displaystyle\sum_{i=1}^{BN-1} t_*(processBlock) * ceil(i/a) + C * block\_num), \ C \in R`$

#### Результаты подсчетов
По расчитанным выше формулам было вычеслено ожидаемое уксорение при распараллеливании.
Везде $`iter`$ принималось равным $`1`$, так как этого достаточно, чтобы рассчитать ускорение.
### Фактические показатели

### Результат