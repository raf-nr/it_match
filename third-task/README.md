# Задача 3: BMP compressor
<details>
<summary>Условие задачи</summary>
Часть I

Реализуйте программу на языке Python, которая производит сжатие изображения в формате bmp (24
бита на цвет) с минимизацией потери качества при фиксированном ограничении на размер сжатого
файла, используя теорию малоранговых приближений. Ваша программа должна семантически
распадаться на две единицы логики: формирование промежуточного представления на основе
исходного изображения, а также восстановление, использующее промежуточное представление.
Для хранения промежуточного сжатого представления используйте собственный формат файла; его
размер (включая область метаданных) должен быть в хотя бы в N раз меньше исходного, где N –
настраиваемый параметр. Напишите краткую документацию предложенного вами формата и
приложите её к решению задачи.

Сингулярное разложение реализуйте тремя способами:
- пользуясь стандартными библиотеками
- с помощью самописного примитивного алгоритма
- “максимально хорошим” численным методом, который у вас получится написать

Обратите внимание, что даже в рамках стандартных библиотек Python есть две реализации SVD.
Можно попробовать обратиться к исходному коду, описаниям реализации и исходя из этого
подумать о частных случаях, позволяющих улучшать качество.
Роль примитивного алгоритма могут выполнять, например, степенной метод или какой-то из
описанных в пособии Дж Голуб, Ч. ван Лоун "Матричные вычисления." – Москва: Мир, 1999.

Приведу также пару статей, в которых излагаются современные подходы к решению задачи, но это
вовсе не значит, что вам нужно и даже стоит использовать именно их.
- https://core.ac.uk/download/pdf/82260137.pdf
- https://www.degruyter.com/document/doi/10.1515/jisys-2018-0034/html

Часть II

Подберите достаточно большое изображение, на котором будет (насколько это возможно видна)
разница в сохранности или потере ключевых признаков при его сжатии в одинаковое количество
раз при использовании различных реализаций SVD.
Возможно, эта задача не решится путём подбора изображения. Тогда следует отталкиваться от того,
какие матрицы каким алгоритмом лучше обрабатывать. То есть рассматривать матрицу как
первичный объект, а построенное на его основе изображение — как вторичный. 
</details>

## CLI
Программе передаются следующие аргументы командной строки:

* `--mode=<mode>` – может быть compress или decompress
  * `--mode=compress` – программа преобразует изображение в промежуточное представление
  * `--mode=decompress` – программа восстанавливает изображение из промежуточного представления

* `--method=<method>` (есть, если `--mode=compress`) – задаёт способ сингулярного разложения:
  * `--method=numpy` – для сингулярного разложения используется numpy
  * `--method=simple` – для сингулярного разложения используется примитивный алгоритм
  * `--method=advanced` – для сингулярного разложения используется максимально “хороший” численный метод

* `--compression=<N>` (есть, если `--mode=compress`) – число раз, в которое размер исходного изображения должен быть
  больше размера промежуточного представления: (размер изображения) / (размер пром. представления) >= N

* `--in_file=<path>` – путь до преобразуемого файла
  * Если `--mode=compress` – путь до исходного изображения
  * Если `--mode=decompress` – путь до промежуточного представления

* `--out_file=<path>` – файл с результатом
  * Если `--mode=compress` – файл, в который будет выводиться промежуточное представление
  * Если `--mode=decompress` – файл, в который будет выводиться восстановленное изображение

## Формат .msvd
В файлах этого формата хранятся сингулярные разложения `$A=USV^T$`.
00-04: сигнатура файла - `$MSVD$`.
04-08: высота картинки.
08-0C: количество сингулярных чисел.
0C-10: ширина картинки.
Дальше для каждого канала цвета представлено его сингулярное разложение - `$U$`, `$S$`, `$V^T$`. Хранятся они в `float32`. Сначала красный цвет, потом зеленый, потом синий.

## Реализация и эксперимент

### Алгоритмы
Было реализовано 3 алгоритма SVD:
- библиотечный (из numpy).
- power method.
- block power method.

### Условия эксперимента
- Во всех экспериментах `compression=5`.

### Результаты
| Numpy                                              | Simple                                              | Advanced                                              |
|----------------------------------------------------|-----------------------------------------------------|-------------------------------------------------------|
| ![](images/compressed_images_bmp/first_numpy.bmp)  | ![](images/compressed_images_bmp/first_simple.bmp)  | ![](images/compressed_images_bmp/first_advanced.bmp)  |
| ![](images/compressed_images_bmp/second_numpy.bmp) | ![](images/compressed_images_bmp/second_simple.bmp) | ![](images/compressed_images_bmp/second_advanced.bmp) |
| ![](images/compressed_images_bmp/third_numpy.bmp)  | ![](images/compressed_images_bmp/third_simple.bmp)  | ![](images/compressed_images_bmp/third_advanced.bmp)  |
| ![](images/compressed_images_bmp/fourth_numpy.bmp) | ![](images/compressed_images_bmp/fourth_simple.bmp) | ![](images/compressed_images_bmp/fourth_advanced.bmp) |

### Наблюдения
- На изображениях с лунтиком видно, что numpy и advanced дают практически одинаковый результат, а вот simple даёт результат по хуже.
- На изображении с Ксюшей все алгоритмы дают практически одинаковый результат, однако если очень сильно присмотреть, можно увидеть, что в simple буквы видно немного похуже.
- На изображении с треугольниками numpy и advanced снова дают практически одинаковый результат, а simple наводит много грязюки в центре.
- На изображении с линиями можно заметить, что все алгоритмы дали разные результаты, однако на удивление simple и advanced здесь наиболее схожи.

### Выводы
В большинстве случаев выходит, что simple работает хуже numpy/advanced. Если же учесть то, что numpy работает намного быстрее simple/advanced, можно рекомендовать из предложенных методов использовать именно его.